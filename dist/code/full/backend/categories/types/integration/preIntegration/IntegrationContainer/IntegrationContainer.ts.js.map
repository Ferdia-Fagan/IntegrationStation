{"version":3,"file":"code/full/backend/categories/types/integration/preIntegration/IntegrationContainer/IntegrationContainer.ts.js","mappings":";;;UAAA;UACA;;;;;WCDA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;ACKO,IAAU,uBAAuB,CAyFvC;AAzFD,WAAiB,uBAAuB;IAEpC,IAAiB,KAAK,CAoFrB;IApFD,WAAiB,KAAK;IAoFtB,CAAC,EApFgB,KAAK,GAAL,6BAAK,KAAL,6BAAK,QAoFrB;AAGL,CAAC,EAzFgB,uBAAuB,KAAvB,uBAAuB,QAyFvC","sources":["webpack://dist/webpack/bootstrap","webpack://dist/webpack/runtime/define property getters","webpack://dist/webpack/runtime/hasOwnProperty shorthand","webpack://dist/webpack/runtime/make namespace object","webpack://dist/./src/code/full/backend/categories/types/integration/preIntegration/IntegrationContainer/IntegrationContainer.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import {\n    KeysOfPropertiesOfT,\n    SubOfTWithOnlyMethods,\n    SubOfTWithOnlyProperties,\n    TWithOnlyMethods,\n    TWithOnlyProperties\n} from \"../../../utils/Filtering\";\nimport {UnionToIntersection} from \"../../../utils/TypeTransformations\";\nimport {ChildComponent_NS} from \"../ChildComponent/ChildComponent\";\nimport {IntegratedComponent_NS} from \"../IntegratedComponent/IntegratedComponent\";\n\nexport namespace IntegrationContainer_NS {\n\n    export namespace Types {\n\n        export declare const IntegrationContainerSymbol: unique symbol\n\n        export interface IntegrationContainer {\n            [IntegrationContainerSymbol]: void\n        }\n\n        // TODO: potentially bad\n        export type ContainerOfChildComponent<Cc, refName extends keyof Iccc, Iccc> = {\n            [k in refName]: Iccc[k] extends Cc ? Cc : never;\n        }\n\n        // export type ContainerOfT<Cc, key extends string> = {\n        //     [k in key]: Cc extends infer R ? R : never\n        // }\n        //\n        // export type PossibleContainerOfT<\n        //     Cc,\n        //     Iccc extends ChildComponent_NS.Types.ChildComponentT<Cc>\n        // > =\n        //     Iccc\n\n        // TODO: I want to include specifying the interface for the Integration Component Container local  controller\n        export interface IntegrationChildComponentContainerIntegrationConstructor<Cc,\n            refName extends keyof Iccc,\n            Iccc extends ContainerOfChildComponent<Cc, refName, Iccc>,\n            Ic extends IntegratedComponent_NS.Types.IntegratedComponentT<Cc,\n                refName,\n                Iccc>> {\n            integrateIntegrationChildComponentContainer(cc: ChildComponent_NS.Types.SpecificChildComponent<Cc, refName, Iccc>): Ic\n        }\n\n        export namespace Transformations {\n\n            import ChildComponentT = ChildComponent_NS.Types.ChildComponentT;\n\n            /**\n             * Get total coverage of container and all categories\n             * TODO: Components should be able to be specified with decorator\n             */\n            export type CoverageOfContainer<Iccc> = Partial<UnionToIntersection<ChildComponentOfContainer<Iccc> & TWithOnlyMethods<Iccc>>>\n\n            export type CoverageOfContainerAndComponents<Iccc,\n                componentKeys extends KeysOfPropertiesOfT<Iccc>> =\n                Partial<UnionToIntersection<Iccc[componentKeys]> & TWithOnlyMethods<Iccc>>\n\n            export type CoverageOfContainerAndComponentsArray<Iccc,\n                Ccs extends ChildComponentT<Iccc>> =\n                Partial<UnionToIntersection<Ccs & TWithOnlyMethods<Iccc>>>\n\n            export type CoverageOfContainerAndComponentsType<Iccc,\n                Ccs extends ChildComponentT<Iccc> | KeysOfPropertiesOfT<Iccc>> =\n                Ccs extends ChildComponentT<Iccc> ? CoverageOfContainerAndComponentsArray<Iccc, Ccs> :\n                    Ccs extends KeysOfPropertiesOfT<Iccc> ? CoverageOfContainerAndComponents<Iccc, Ccs> :\n                        never\n\n            /**\n             * *** IntegrationChildComponentContainer ***\n             *\n             * Gets all properties (filtering methods) from Iccc\n             */\n            export type ChildComponentOfContainer<Iccc> =\n                UnionToIntersection<SubOfTWithOnlyProperties<Iccc>>\n\n            export type ChildComponentExtractionPair<\n                Iccc,\n                childComponentKey extends keyof ChildComponentOfContainer<Iccc>\n            >\n                = [\n                childComponentKey,\n                (keyof TWithOnlyMethods<Exclude<ChildComponentOfContainer<Iccc>[childComponentKey], undefined>>)[]\n            ]\n\n            export type ChildComponentExtractionPairs<\n                Iccc\n            > = (\n                {\n                    [key in keyof ChildComponentOfContainer<Iccc>]: ChildComponentExtractionPair<Iccc, key>\n                }[keyof ChildComponentOfContainer<Iccc>]\n            )[]\n\n        }\n\n    }\n\n\n}\n\nexport type IsCovered<L extends R, R> = Pick<L, keyof R>\n"],"names":[],"sourceRoot":""}