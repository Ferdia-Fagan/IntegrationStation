{"version":3,"file":"code/full/backend/categories/types/integration/preIntegration/IntegratedComponent/tests/Types_V2_IntegratedComponent.test.ts.js","mappings":";;;;;;;;;;;AAAa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;;;;;;;UCRd;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;ACNwD;AAUxD,QAAQ,CAAC,wBAAwB,EAAE,GAAG,EAAE;IAEpC,QAAQ,CAAC,OAAO,EAAE,GAAG,EAAE;QAEnB,EAAE,CAAC,IAAI,CAAC,qBAAqB,CAAC;QAE9B,EAAE,CAAC,wBAAwB,EAAE,GAAG,EAAE;YAmC9B,MAAM,EAAE,GAAM;gBACV,SAAS;oBACL,OAAO,CAAC,CAAC;gBACb,CAAC,EAAE,SAAS;oBACR,OAAO,CAAC,CAAC;gBACb,CAAC,EAAE,SAAS;oBACR,OAAO,CAAC,CAAC;gBACb,CAAC;aAEJ;YAED,MAAM,GAAG,GAAO;gBACZ,SAAS;oBACL,OAAO,CAAC,CAAC;gBACb,CAAC,EAAE,SAAS;oBACR,OAAO,CAAC,CAAC;gBACb,CAAC,EAAE,SAAS;oBACR,OAAO,CAAC,CAAC;gBACb,CAAC;aAEJ;YAOD,MAAM,gCAAgC,GAAiC;gBACnE,SAAS;oBACL,OAAO,CAAC,CAAC;gBACb,CAAC,EAAE,SAAS;oBACR,OAAO,CAAC,CAAC;gBACb,CAAC;gBACC,SAAS;oBACP,OAAO,CAAC,CAAC;gBACb,CAAC;aAEJ;YAOD,MAAM,uBAAuB,GAAwB;gBACjD,SAAS;oBACL,OAAO,CAAC,CAAC;gBACb,CAAC,EAAE,SAAS;oBACR,OAAO,CAAC,CAAC;gBACb,CAAC;gBACC,SAAS;oBACP,OAAO,CAAC,CAAC;gBACb,CAAC;aAEJ;YAcD,+DAAM,CAGH,IAAI,CAAC;YAmBR,wDAAwD;YACxD,wBAAwB;YACxB,qBAAqB;YACrB,QAAQ;YACR,IAAI;YACJ,EAAE;YACF,2EAA2E;YAC3E,kEAAkE;QAEtE,CAAC,CAAC;IAEN,CAAC,CAAC;AAGN,CAAC,CAAC","sources":["webpack://dist/./node_modules/conditional-type-checks/dist/index.js","webpack://dist/webpack/bootstrap","webpack://dist/webpack/runtime/make namespace object","webpack://dist/./src/code/full/backend/categories/types/integration/preIntegration/IntegratedComponent/tests/Types_V2_IntegratedComponent.test.ts"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Asserts at compile time that the provided type argument's type resolves to the expected boolean literal type.\r\n * @param expectTrue - True if the passed in type argument resolved to true.\r\n */\r\nfunction assert(expectTrue) {\r\n}\r\nexports.assert = assert;\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import {assert, IsExact} from \"conditional-type-checks\";\nimport {DoesLTypeExtendsRType} from \"../../../../../../../../../../tests/testingUtils/TypeTesting\";\nimport {IntegratedComponent_NS} from \"../IntegratedComponent\";\nimport {IntegrationContainer_NS} from \"../../IntegrationContainer/IntegrationContainer\";\nimport CoverageOfContainerAndComponentsArray = IntegrationContainer_NS.Types.Transformations.CoverageOfContainerAndComponentsArray;\nimport CoverageOfContainerAndComponents = IntegrationContainer_NS.Types.Transformations.CoverageOfContainerAndComponents;\nimport CoverageOfContainerAndComponentsType = IntegrationContainer_NS.Types.Transformations.CoverageOfContainerAndComponentsType;\nimport IntegrateableComponent = IntegratedComponent_NS.Types.SpecificIntegrableComponent;\nimport IntegrableComponent = IntegratedComponent_NS.Types.IntegrableComponent;\n\ndescribe('IntegratedComponent_NS', () => {\n\n    describe('Types', () => {\n\n        it.todo('IntegratedComponent')\n\n        it('IntegrateableComponent', () => {\n            // given\n            interface ChildComponentInterface1 {\n                function1(): number\n            }\n            interface ChildComponentInterface2 {\n                function2(): number\n            }\n            interface NotChildComponentInterface {\n                function4(): number\n            }\n\n            interface Container {\n                component1: ChildComponentInterface1\n                component2: ChildComponentInterface2\n                function3(): number\n            }\n\n            interface DesiredIntegratedComponentInterface {\n                function1(): number\n                function2(): number\n                function3(): number\n            }\n\n            // when\n            // type xx =\n\n            // type x = CoverageOfContainerAndComponentsArray<\n            //     Container, ChildComponentInterface1 | ChildComponentInterface2\n            // >\n            // type xa = CoverageOfContainerAndComponents<Container, 'component1' | 'component2'>\n            type x = CoverageOfContainerAndComponentsType<Container, ChildComponentInterface1 | ChildComponentInterface2>\n            type xa = CoverageOfContainerAndComponentsType<Container, 'component1' | 'component2'>\n\n\n            const xi: x = {\n                function1(): number {\n                    return 0;\n                }, function2(): number {\n                    return 0;\n                }, function3(): number {\n                    return 0;\n                }\n\n            }\n\n            const xai: xa = {\n                function1(): number {\n                    return 0;\n                }, function2(): number {\n                    return 0;\n                }, function3(): number {\n                    return 0;\n                }\n\n            }\n\n            type specificIntegrableComponentT = IntegrateableComponent<\n                Container,\n                ChildComponentInterface1 | ChildComponentInterface2,\n                DesiredIntegratedComponentInterface\n            >\n            const specificIntegrableComponentTInst: specificIntegrableComponentT = {\n                function1(): number {\n                    return 0;\n                }, function2(): number {\n                    return 0;\n                }\n                , function3(): number {\n                    return 0;\n                }\n\n            }\n\n            type integrableComponent = IntegrableComponent<\n                Container,\n                ChildComponentInterface1 | ChildComponentInterface2\n            >\n\n            const integrableComponentInst: integrableComponent = {\n                function1(): number {\n                    return 0;\n                }, function2(): number {\n                    return 0;\n                }\n                , function3(): number {\n                    return 0;\n                }\n\n            }\n\n            interface right {\n                function1(): number\n                function2(): number\n                function3(): number\n            }\n\n            interface wrong {\n                function1(): number\n                function2(): number\n                function5(): number\n            }\n\n            assert<DoesLTypeExtendsRType<\n                Required<DesiredIntegratedComponentInterface>,\n                Required<specificIntegrableComponentT>\n            >>(true)\n            // type X1 = Pick<right, keyof Required<integrableComponent>>\n            // type X = Exclude<right, >\n            // type fdslkj = keyof Required<integrableComponent>\n            // function OIJKDXSOn(d: fdslkj): fdslkj {\n            //     return d\n            // }\n            // OIJKDXSOn(\"function1\")\n\n            interface XXX {\n                first(): number\n                second(): number\n            }\n\n            interface YYY {\n                first(): number\n                second(): number\n            }\n\n            // const irew: Omit<XXX, keyof Pick<XXX, keyof YYY>> = {\n            //     first(): number {\n            //         return 109\n            //     }\n            // }\n            //\n            // assert<DoesLTypeExtendsRType<right,Required<integrableComponent>>>(true)\n            // assert<DoesLTypeExtendsRType<integrableComponent,wrong>>(false)\n\n        })\n\n    })\n\n\n})\n\n\n\n"],"names":[],"sourceRoot":""}