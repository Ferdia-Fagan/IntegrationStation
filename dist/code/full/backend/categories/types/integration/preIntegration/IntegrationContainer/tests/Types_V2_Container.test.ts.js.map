{"version":3,"file":"code/full/backend/categories/types/integration/preIntegration/IntegrationContainer/tests/Types_V2_Container.test.ts.js","mappings":";;;;;;;;;;;AAAa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;;;;;;;;;;;;;;;;;UCRd;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA;WACA,iCAAiC,WAAW;WAC5C;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;ACNiE;AACxB;AAczC,QAAQ,CAAC,yBAAyB,EAAE,GAAG,EAAE;IAErC,QAAQ,CAAC,OAAO,EAAE,GAAG,EAAE;QAEnB,EAAE,CAAC,IAAI,CAAC,2BAA2B,CAAC;IAExC,CAAC,CAAC;IAEF,QAAQ,CAAC,iBAAiB,EAAE,GAAG,EAAE;QAE7B,EAAE,CAAC,kCAAkC,EAAE,GAAG,EAAE;YAoCxC,OAAO;YACP,+DAAM,CAA2B,KAAK,CAAC;YACvC,+DAAM,CAAqB,KAAK,CAAC;YACjC,+DAAM,CAAwD,IAAI,CAAC;YACnE,+DAAM,CAA+C,IAAI,CAAC;YAE1D,+DAAM,CAAwB,KAAK,CAAC;YACpC,+DAAM,CAAkD,KAAK,CAAC;YAC9D,+DAAM,CAAsE,IAAI,CAAC;YAEjF,+DAAM,CAA+C,IAAI,CAAC;YAC1D,+DAAM,CAAyC,KAAK,CAAC;QACzD,CAAC,CAAC;QAEF,EAAE,CAAC,uCAAuC,EAAE,GAAG,EAAE;YAoC7C,OAAO;YACP,+DAAM,CAA2B,KAAK,CAAC;YACvC,+DAAM,CAAqB,KAAK,CAAC;YACjC,+DAAM,CAAwD,IAAI,CAAC;YACnE,+DAAM,CAA+C,IAAI,CAAC;YAE1D,+DAAM,CAAwB,KAAK,CAAC;YACpC,+DAAM,CAAkD,KAAK,CAAC;YAC9D,+DAAM,CAAsE,IAAI,CAAC;YAEjF,+DAAM,CAA+C,IAAI,CAAC;YAC1D,+DAAM,CAAyC,KAAK,CAAC;QACzD,CAAC,CAAC;QAEF,QAAQ,CAAC,2BAA2B,EAAE,GAAG,EAAE;YAEvC,EAAE,CAAC,qBAAqB,EAAE,GAAG,EAAE;gBAe3B,MAAM,CAAC,GAAG,yDAAI,EAAgC;gBAC9C,MAAM,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;gBACxB,MAAM,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,2BAA2B,EAAE,4BAA4B,CAAC,CAAC;gBAE9E,iHAAiH;gBACjH,4BAA4B;gBAC5B,2BAA2B;gBAC3B,6BAA6B;YACjC,CAAC,CAAC;QAEN,CAAC,CAAC;QAEF,QAAQ,CAAC,+BAA+B,EAAE,GAAG,EAAE;YAE3C,EAAE,CAAC,oDAAoD,EAAE,GAAG,EAAE;gBAyB1D,4IAA4I;gBAC5I,MAAM,IAAI,GAAgB,CAAC,2BAA2B,EAAC,CAAC,QAAQ,CAAC,CAAC;gBAOlE,MAAM,UAAU,GAAW;oBACvB,CAAC,2BAA2B,EAAC,CAAC,QAAQ,CAAC,CAAC;oBACxC,CAAC,4BAA4B,EAAC,CAAC,QAAQ,CAAC,CAAC;iBAC5C;YAEL,CAAC,CAAC;QAEN,CAAC,CAAC;IAEN,CAAC,CAAC;AAGN,CAAC,CAAC","sources":["webpack://dist/./node_modules/conditional-type-checks/dist/index.js","webpack://dist/webpack/bootstrap","webpack://dist/webpack/runtime/compat get default export","webpack://dist/webpack/runtime/define property getters","webpack://dist/webpack/runtime/hasOwnProperty shorthand","webpack://dist/webpack/runtime/make namespace object","webpack://dist/./src/code/full/backend/categories/types/integration/preIntegration/IntegrationContainer/tests/Types_V2_Container.test.ts"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Asserts at compile time that the provided type argument's type resolves to the expected boolean literal type.\r\n * @param expectTrue - True if the passed in type argument resolved to true.\r\n */\r\nfunction assert(expectTrue) {\r\n}\r\nexports.assert = assert;\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import {assert, IsExact, IsNever} from \"conditional-type-checks\";\nimport {keys} from \"ts-transformer-keys\";\nimport {\n    SubOfTWithOnlyMethods,\n    SubOfTWithOnlyProperties,\n    TWithOnlyMethods,\n    TWithOnlyProperties\n} from \"../../../../utils/Filtering\";\nimport {IntegrationContainer_NS} from \"../IntegrationContainer\";\nimport CoverageOfContainerAndComponents = IntegrationContainer_NS.Types.Transformations.CoverageOfContainerAndComponents;\nimport CoverageOfContainerAndComponentsArray = IntegrationContainer_NS.Types.Transformations.CoverageOfContainerAndComponentsArray;\nimport ChildComponentOfContainer = IntegrationContainer_NS.Types.Transformations.ChildComponentOfContainer;\nimport ChildComponentExtractionPairs = IntegrationContainer_NS.Types.Transformations.ChildComponentExtractionPairs;\nimport ChildComponentExtractionPair = IntegrationContainer_NS.Types.Transformations.ChildComponentExtractionPair;\n\ndescribe('IntegrationContainer_NS', () => {\n\n    describe('types', () => {\n\n        it.todo('ContainerOfChildComponent')\n\n    })\n\n    describe('transformations', () => {\n\n        it('CoverageOfContainerAndComponents', () => {\n            // given:\n            interface ChildComponentInterface1 {\n                function1(): number\n            }\n            interface ChildComponentInterface2 {\n                function2(): number\n            }\n\n            interface Container {\n                component1: ChildComponentInterface1\n                component2: ChildComponentInterface2\n                function3(): number\n            }\n\n            interface TheSpread {\n                function1(): number\n                function2(): number\n                function3(): number\n                // function4(): number\n                // function5(): number\n            }\n            interface NotTheSpread {\n                function1(): number\n                function2(): number\n                function3(): number\n                function4(): number\n                function5(): number\n            }\n\n\n            // when\n            type coverageOfXAndY = CoverageOfContainerAndComponents<\n                Container, \"component1\" | \"component2\"\n            >\n\n            // then\n            assert<IsNever<coverageOfXAndY>>(false)\n            assert<IsNever<TheSpread>>(false)\n            assert<IsNever<Exclude<coverageOfXAndY, Partial<TheSpread>>>>(true)\n            assert<IsNever<Exclude<TheSpread, coverageOfXAndY>>>(true)\n\n            assert<IsNever<NotTheSpread>>(false)\n            assert<IsNever<Exclude<coverageOfXAndY, NotTheSpread>>>(false)\n            assert<IsNever<Exclude<Required<NotTheSpread>, Required<coverageOfXAndY>>>>(true)\n\n            assert<IsExact<coverageOfXAndY, Partial<TheSpread>>>(true)\n            assert<IsExact<coverageOfXAndY, NotTheSpread>>(false)\n        })\n\n        it('CoverageOfContainerAndComponentsArray', () => {\n            // given:\n            interface ChildComponentInterface1 {\n                function1(): number\n            }\n            interface ChildComponentInterface2 {\n                function2(): number\n            }\n\n            interface Container {\n                component1: ChildComponentInterface1\n                component2: ChildComponentInterface2\n                function3(): number\n            }\n\n            interface TheSpread {\n                function1(): number\n                function2(): number\n                function3(): number\n                // function4(): number\n                // function5(): number\n            }\n            interface NotTheSpread {\n                function1(): number\n                function2(): number\n                function3(): number\n                function4(): number\n                function5(): number\n            }\n\n\n            // when\n            type coverageOfXAndY = CoverageOfContainerAndComponentsArray<\n                Container, ChildComponentInterface1 | ChildComponentInterface2\n            >\n\n            // then\n            assert<IsNever<coverageOfXAndY>>(false)\n            assert<IsNever<TheSpread>>(false)\n            assert<IsNever<Exclude<coverageOfXAndY, Partial<TheSpread>>>>(true)\n            assert<IsNever<Exclude<TheSpread, coverageOfXAndY>>>(true)\n\n            assert<IsNever<NotTheSpread>>(false)\n            assert<IsNever<Exclude<coverageOfXAndY, NotTheSpread>>>(false)\n            assert<IsNever<Exclude<Required<NotTheSpread>, Required<coverageOfXAndY>>>>(true)\n\n            assert<IsExact<coverageOfXAndY, Partial<TheSpread>>>(true)\n            assert<IsExact<coverageOfXAndY, NotTheSpread>>(false)\n        })\n\n        describe('ChildComponentOfContainer', () => {\n\n            it('will look like type', () => {\n\n                interface ExampleChildComponent {\n                    func1(): string\n                }\n                interface ExampleChildComponent2 {\n                    func1(): string\n                }\n\n                interface ExampleChildComponentContainer {\n                    exampleChildComponentInst: ExampleChildComponent\n                    exampleChildComponentInst2: ExampleChildComponent2\n                }\n\n                type childComponentMapOfContainer = ChildComponentOfContainer<ExampleChildComponentContainer>\n                const x = keys<childComponentMapOfContainer>()\n                expect(x.length).toBe(2)\n                expect(x).toEqual([\"exampleChildComponentInst\", \"exampleChildComponentInst2\"])\n\n                // type example = ChildComponentOfContainer<ExampleChildComponentContainer>[keyof ExampleChildComponentContainer]\n                // const x = keys<example>()\n                // expect(x.length).toBe(1)\n                // expect(x[0]).toBe(\"func1\")\n            })\n\n        })\n\n        describe('ChildComponentExtractionPairs', () => {\n\n            it('defines a list of child component extraction pairs', () => {\n                interface ExampleChildComponent {\n                    func11(): string\n                    func12(): string\n                }\n                interface ExampleChildComponent2 {\n                    func21(): string\n                    func22(): string\n                }\n\n                interface ExampleChildComponentContainer {\n                    exampleChildComponentInst: ExampleChildComponent\n                    exampleChildComponentInst2: ExampleChildComponent2\n                }\n\n                interface ExampleExtraction {\n                    func11(): string\n                }\n\n                // type x = keyof ChildComponentOfContainer<ExampleChildComponentContainer>\n\n                type otherResult = ChildComponentExtractionPair<\n                        ExampleChildComponentContainer,\n                        \"exampleChildComponentInst\"\n                    >\n                // type a = (TWithOnlyMethods<Exclude<ChildComponentOfContainer<ExampleChildComponentContainer>[\"exampleChildComponentInst\"], undefined>>)[]\n                const fdsa: otherResult = [\"exampleChildComponentInst\",[\"func11\"]]\n\n                type result = Exclude<\n                    ChildComponentExtractionPairs<ExampleChildComponentContainer>,\n                    undefined\n                >\n\n                const resultInst: result = [\n                    [\"exampleChildComponentInst\",[\"func11\"]],\n                    [\"exampleChildComponentInst2\",[\"func21\"]],\n                ]\n\n            })\n\n        })\n\n    })\n\n\n})\n\n\n"],"names":[],"sourceRoot":""}