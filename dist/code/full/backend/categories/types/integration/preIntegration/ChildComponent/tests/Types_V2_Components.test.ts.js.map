{"version":3,"file":"code/full/backend/categories/types/integration/preIntegration/ChildComponent/tests/Types_V2_Components.test.ts.js","mappings":"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","sources":["webpack://dist/./node_modules/conditional-type-checks/dist/index.js","webpack://dist/./src/code/full/backend/categories/types/integration/preIntegration/ChildComponent/ChildComponent.ts","webpack://dist/webpack/bootstrap","webpack://dist/webpack/runtime/define property getters","webpack://dist/webpack/runtime/hasOwnProperty shorthand","webpack://dist/webpack/runtime/make namespace object","webpack://dist/./src/code/full/backend/categories/types/integration/preIntegration/ChildComponent/tests/Types_V2_Components.test.ts"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Asserts at compile time that the provided type argument's type resolves to the expected boolean literal type.\r\n * @param expectTrue - True if the passed in type argument resolved to true.\r\n */\r\nfunction assert(expectTrue) {\r\n}\r\nexports.assert = assert;\r\n","import {FilteredKeysByNotType, KeysOfPropertiesOfT} from \"../../../utils/Filtering\";\nimport {UnionToIntersection} from \"../../../utils/TypeTransformations\";\nimport {IntegrationContainer_NS} from \"../IntegrationContainer/IntegrationContainer\";\n\nexport namespace ChildComponent_NS {\n\n    export namespace Types {\n\n        export declare const ChildComponentSymbol: unique symbol\n\n        export interface ChildComponent {\n            [ChildComponentSymbol]: void\n        }\n\n        export type ChildComponentMapKey<Iccc> = keyof Iccc\n\n        export type SpecificChildComponent<Cc,\n            refName extends ChildComponentMapKey<Iccc>,\n            Iccc // extends IntegrationContainer_NS.Types.ContainerOfChildComponent<Cc, refName, Iccc>\n            > =\n            Iccc[refName] extends Cc ? Cc : never\n\n        export type ChildComponentT<Iccc> = {\n            [key in KeysOfPropertiesOfT<Iccc>]: Iccc[key] extends infer R ? Iccc[key] : never\n        }[FilteredKeysByNotType<Iccc, Function>]\n\n        export type ChildComponentsMapWithinContainer<Iccc> = {\n            [key in KeysOfPropertiesOfT<Iccc>]?: Iccc[key] extends infer R ? Iccc[key] : never\n        }\n\n        export type IntegrationContainerChildComponentsArray<Iccc> = {\n            [key in KeysOfPropertiesOfT<Iccc>]?: Iccc[key] extends infer R ? Iccc[key] : never\n        }[KeysOfPropertiesOfT<Iccc>]\n\n        export namespace Checks {\n\n            // TODO: fix\n            // export function isChildComponent<\n            //     Cc,\n            //     CcRefName extends keyof Iccc,\n            //     Iccc extends IntegrationContainer_NS.Types.ContainerOfChildComponent<Cc, CcRefName, Iccc>\n            // > (potentialChildComponent: unknown, ccRefName: CcRefName, iccc: Iccc): potentialChildComponent is ChildComponent<Cc, CcRefName, Iccc> {\n            //     return iccc[ccRefName] == potentialChildComponent\n            // }\n\n        }\n\n        export namespace Transformations {\n\n            import ChildComponentOfContainer = IntegrationContainer_NS.Types.Transformations.ChildComponentOfContainer;\n            export type CoverageByComponents<COMPONENTS extends ChildComponent_NS.Types.ChildComponentT<any>> =\n                UnionToIntersection<COMPONENTS>\n\n            /**\n             * Tested: done\n             */\n            export type CoverageByComponentsArray<COMPONENTS extends Array<ChildComponent_NS.Types.ChildComponentT<any>>> =\n                UnionToIntersection<COMPONENTS[number]>\n\n            export type ChildComponentSubInterfaceT<componentI, subI> = subI extends Partial<componentI> ? subI : never\n\n            export type ValidChildComponent<Iccc> = ChildComponentOfContainer<Iccc>[keyof ChildComponentOfContainer<Iccc>]\n        }\n\n    }\n\n\n\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import {assert, IsExact, IsNever} from \"conditional-type-checks\";\nimport {IsTWithinUnion, TypesAreTheSame} from \"../../../../../../../../../../tests/testingUtils/TypeTesting\";\nimport {KeysOfPropertiesOfT} from \"../../../../utils/Filtering\";\nimport {ChildComponent_NS} from \"../ChildComponent\";\nimport SpecificChildComponent = ChildComponent_NS.Types.SpecificChildComponent;\nimport ChildComponentT = ChildComponent_NS.Types.ChildComponentT;\nimport ChildComponentsMapWithinContainer = ChildComponent_NS.Types.ChildComponentsMapWithinContainer;\nimport IntegrationContainerChildComponentsArray = ChildComponent_NS.Types.IntegrationContainerChildComponentsArray;\nimport CoverageByComponentsArray = ChildComponent_NS.Types.Transformations.CoverageByComponentsArray;\nimport ChildComponent = ChildComponent_NS.Types.ChildComponent;\n\ndescribe('ChildComponent_NS', () => {\n    \n    describe('Types', () => {\n\n        it(\"symbol\", () => {\n\n            interface SampleComponentInterface {\n                fun1(): number\n            }\n\n            interface SampleComponent extends ChildComponent, SampleComponentInterface {\n            }\n\n            class SampleComponentImpl implements SampleComponent {\n                [ChildComponent_NS.Types.ChildComponentSymbol]: void\n                fun1(): number {\n                    return 10\n                }\n            }\n\n            class SampleComponentImplImpersonator {\n                fun1(): number {\n                    return 10\n                }\n            }\n\n\n\n            let sampleComponentInst = new SampleComponentImpl()\n            let sampleComponentInstImpersonator = new SampleComponentImplImpersonator()\n\n            type x = Pick<SampleComponent, keyof ChildComponent>\n\n            assert<IsNever<\n                Pick<SampleComponent, keyof ChildComponent>\n            >>(false)\n            assert<IsNever<\n                Pick<SampleComponentImpl, keyof ChildComponent>\n            >>(false)\n\n            // function isA(s: SampleComponent): SampleComponent {\n            //     return s\n            // }\n            //\n            // isA(sampleComponentInst)\n            // isA(sampleComponentInstImpersonator)\n\n\n\n            // let sampleComponentInstObj: SampleComponent = {\n            //     [ChildComponentSymbolllll]: undefined\n            // }\n\n            // function isAComponent<SampleComponentInterface>(potentialComponent: SampleComponentInterface): potentialComponent is ChildComponent {\n            //     // const x = typeof potentialComponent\n            //     // const y = potentialComponent.ChildComponentSymbol\n            //     // const x = potentialComponent.afddsa\n            //     const z = ChildComponent_NS.Types.ChildComponentSymbol in potentialComponent\n            //     const a = (ChildComponent_NS.Types.ChildComponentSymbol in potentialComponent) && potentialComponent[ChildComponent_NS.Types.ChildComponentSymbol]\n            //     // return potentialComponent.ChildComponentSymbol !== undefined\n            //     return false\n            // }\n            const xafds1 = ChildComponent_NS.Types.ChildComponentSymbol\n            const xafds2 = sampleComponentInst[ChildComponent_NS.Types.ChildComponentSymbol]\n            const xafds3 = (ChildComponent_NS.Types.ChildComponentSymbol in sampleComponentInst) && sampleComponentInst[ChildComponent_NS.Types.ChildComponentSymbol]\n\n\n            if(xafds1){\n                const x = sampleComponentInst\n                console.log()\n\n            } else {\n                const x = Object.prototype.hasOwnProperty.call(sampleComponentInst, ChildComponent_NS.Types.ChildComponentSymbol)\n                console.log()\n            }\n\n\n        })\n        \n        // TODO: if SpecificChildComponent needed\n        it('SpecificChildComponent', () => {\n            // given\n            interface ChildComponentInterface1 {\n                function1(): number\n            }\n            interface NotChildComponentInterface {\n                function2(): number\n                function3(): number\n            }\n\n            interface Container {\n                component1: ChildComponentInterface1\n                function3(): number\n            }\n\n            // when\n            assert<IsNever<\n                SpecificChildComponent<ChildComponentInterface1, 'component1', Container>\n            >>(false)\n            assert<IsNever<\n                SpecificChildComponent<NotChildComponentInterface, 'component1', Container>\n            >>(true)\n        })\n        \n        it('ChildComponentT', () => {\n            // given\n            interface ChildComponentInterface1 {\n                function1(): number\n            }\n            interface ChildComponentInterface2 {\n                function2(): number\n            }\n            interface NotChildComponentInterface {\n                function3(): number\n            }\n    \n            interface Container {\n                component1: ChildComponentInterface1\n                component2: ChildComponentInterface2\n                function4(): number\n            }\n            \n            // when\n            type ChildComponentOfContainerType1 = Exclude<ChildComponentInterface1, ChildComponentT<Container>> extends ChildComponentInterface1 ? true : false\n            type ChildComponentOfContainerType2 = Exclude<ChildComponentInterface1, ChildComponentT<Container>> extends ChildComponentInterface1 ? true : false\n            type NotChildComponentOfContainerType = ChildComponentT<Container> extends NotChildComponentInterface ? true : false\n            \n            assert<ChildComponentOfContainerType1>(true)\n            assert<ChildComponentOfContainerType2>(true)\n            assert<NotChildComponentOfContainerType>(false)\n        })\n\n        it(\"ChildComponentsMapWithinContainer\", () => {\n            // given:\n            interface ChildComponentInterface1 {\n                function1(): number\n            }\n            interface ChildComponentInterface2 {\n                function2(): number\n            }\n\n            interface Container {\n                component1: ChildComponentInterface1\n                component2: ChildComponentInterface2\n                function3(): number\n            }\n\n            // when\n            type childComponentsMapT = ChildComponentsMapWithinContainer<Container>\n\n            interface childComponentMap{\n                component1: ChildComponentInterface1\n                component2: ChildComponentInterface2\n            }\n            interface notChildComponentMap{\n                component1: ChildComponentInterface1\n                component3: ChildComponentInterface2\n            }\n\n            // then\n            assert<IsNever<Exclude<childComponentMap, Required<childComponentsMapT>>>>(true)\n            assert<IsNever<Exclude<notChildComponentMap, Required<childComponentsMapT>>>>(false)\n        })\n\n        it('IntegrationContainerChildComponentsArray', () => {\n            // given:\n            interface ChildComponentInterface1 {\n                function1(): number\n            }\n            interface ChildComponentInterface2 {\n                function2(): number\n            }\n            interface NotComponentInterface {\n                function3(): number\n            }\n\n            interface Container {\n                component1: ChildComponentInterface1\n                component2: ChildComponentInterface2\n                function3(): number\n            }\n\n            // when\n            type childComponentsArray = IntegrationContainerChildComponentsArray<\n                Container\n            >\n\n            // then\n            assert<IsTWithinUnion<ChildComponentInterface1, childComponentsArray>>(true)\n            assert<IsTWithinUnion<NotComponentInterface, childComponentsArray>>(false)\n\n            // interface TheSpread {\n            //     function1(): number\n            //     function2(): number\n            // }\n            // interface NotTheSpread {\n            //     function3(): number\n            //     function4(): number\n            // }\n            //\n            // // then\n            // assert<TypesAreTheSame<TheSpread, spreadOfChildComponents>>(true)\n        })\n\n    })\n    \n    describe('Transformations', () => {\n        it('CoverageByComponents', () => {\n            // given:\n            interface X {\n                function1(): number\n            }\n            const x: X = {\n                function1(): number {\n                    return 0;\n                }\n            }\n\n            interface Y {\n                function2(): number\n            }\n            const y: Y = {\n                function2(): number {\n                    return 0;\n                }\n            }\n\n            interface TheSpread {\n                function1(): number\n                function2(): number\n            }\n            interface NotTheSpread {\n                function3(): number\n                function4(): number\n            }\n\n\n            // when\n            const l = [x,y]\n            type coverageOfXAndY = CoverageByComponentsArray<typeof l>\n\n            // then\n            assert<IsExact<coverageOfXAndY, TheSpread>>(true)\n            assert<IsExact<coverageOfXAndY, NotTheSpread>>(false)\n        })\n    })\n\n\n\n})\n\n\n"],"names":[],"sourceRoot":""}